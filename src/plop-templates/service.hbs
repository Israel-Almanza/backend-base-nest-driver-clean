import { Injectable } from '@nestjs/common';
import { {{pascalCase name}}RepositoryImpl } from '@/infrastructure/repositories/{{name}}.repository.impl';
import { {{pascalCase name}} } from '@/domain/entities/{{name}}.entity';
import { TransactionService } from '@/infrastructure/database/transaction.service';
import { ErrorApp } from '@/domain/lib/error';

@Injectable()
export class {{pascalCase name}}Service {
    constructor(
        private readonly repo: {{pascalCase name}}RepositoryImpl,
        private readonly transaction: TransactionService,
    ) {}

    async crear(datos: any): Promise<{{pascalCase name}}> {
        let t;
        try {
            t = await this.transaction.create();

            const entity = new {{pascalCase name}}(
                null,
                {{#each fields}}
                datos.{{this}}{{#unless @last}},{{/unless}}
                {{/each}}
            );

            const result = await this.repo.createOrUpdate(entity, t);
            await this.transaction.commit(t);

            return result;
        } catch (error) {
            await this.transaction.rollback(t);
            throw error;
        }
    }

    async actualizar(datos: any): Promise<{{pascalCase name}}> {
        if (!datos.id) {
            throw new Error('El ID es obligatorio para actualizar');
        }

        let t;
        try {
            t = await this.transaction.create();

            const entity = new {{pascalCase name}}(
                datos.id,
                {{#each fields}}
                datos.{{this}}{{#unless @last}},{{/unless}}
                {{/each}}
            );

            const result = await this.repo.createOrUpdate(entity, t);
            await this.transaction.commit(t);

            return result;
        } catch (error) {
            await this.transaction.rollback(t);
            throw error;
        }
    }

    async findOne(params): Promise<{{pascalCase name}}> {
        try {
            return await this.repo.findOne(params);
        } catch (error) {
            throw new ErrorApp(error.message, 400);
        }
    }

    async eliminar(id: number): Promise<number> {
        try {
            return await this.repo.deleteItem(id);
        } catch (error) {
            throw new ErrorApp(error.message, 400);
        }
    }

    async listar(params: any): Promise<{ count: number; rows: {{pascalCase name}}[] }> {
        try {
            return await this.repo.findAll(params);
        } catch (error) {
            throw new ErrorApp(error.message, 400);
        }
    }
}
